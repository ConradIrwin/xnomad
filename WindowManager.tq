import "Accessibility"
import "Layouts"

#NSNotificationCenter
{
    - observe: name with: lambda `self addObserverForName: name object: nil queue: nil usingBlock:lambda`
}

#WindowManager
{
    accessor: @applications             initialValue: []
    accessor: @activeWindows            initialValue: []
    accessor: @inactiveWindows          initialValue: []
    accessor: @windowsInMaster          initialValue: 1
    accessor: @screensThatNeedReflowing initialValue: []
    accessor: @defaultRatio             initialValue: 0.7

    - init
    {
        #currLayouts = {}
        #ratios      = {}
        NSScreen screens each: `screen| currLayouts[screen] = 0`

        #layouts = [TallLayout new, FullscreenLayout new]

        workspace = NSWorkspace sharedWorkspace
        workspace runningApplications each: { runningApp |
            unless runningApp bundleIdentifier hasPrefix: "com.apple.dashboard"
                self addApplicationWithPID: runningApp processIdentifier
        }
        \self currentLayout prepare: self

        center = workspace notificationCenter
        adder   = `n| ~self;    addApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        remover = `n| ~self; removeApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        activator   = `n| ~self;   activateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        deactivator = `n| ~self; deactivateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        center; observe: NSWorkspaceDidLaunchApplicationNotification    with: adder;
                observe: NSWorkspaceDidTerminateApplicationNotification with: remover;
                observe: NSWorkspaceDidUnhideApplicationNotification    with: activator;
                observe: NSWorkspaceDidHideApplicationNotification      with: deactivator
        ^self
    }

    - applicationWithPID: pid
    {
        ^#applications find: `app| (app pid) == pid`
    }
    - addApplicationWithPID: pid
    {
        if (self applicationWithPID: pid)
            ^nil
        app = AccessibilityElement withPID: pid
        unless app isKindOfClass: AccessibilityApplication
            ^nil
        #applications << app

        app[@AXWindows] each: { window |
            self addWindow: window active: (app[@AXHidden] == 0)
        }
        \ Watch for new window notifications
        app observe: @AXWindowCreated on: app with: { newWindow |
            ~self; addWindow: newWindow; reflow
        }
    }

    - addWindow: window `self addWindow: window active: yes`
    - addWindow: window active: isActive
    {
        self markScreenForReflowing: window screen
        unless (window isKindOfClass: AccessibilityWindow) && (window isResizable)
            ^nil
        if isActive && window[@AXMinimized] != 1 {
            #activeWindows insert: window at: 0
            "screen: «window screen»: «NSStringFromRect(window screen flippedFrame)»" print
        } else
            #inactiveWindows << window

        app = self applicationWithPID: window pid
        app observe: @AXUIElementDestroyed on: window with: { _ |
            ~self; removeWindow: window; reflow
        }
        app observe: @AXWindowMiniaturized on: window with: { _ |
            ~self; deactivateWindow: window; reflow
        }
        app observe: @AXWindowDeminiaturized on: window with: { _ |
            ~self; activateWindow: window; reflow
        }
        ^valid
    }

    - managedWindowsForScreen: screen
    {
        ^#activeWindows select: `w| (w level == 0) && (w screen == screen)`
    }
    - managedWindows `self managedWindowsForScreen: nil`

    - activateWindow: window
    {
        self markScreenForReflowing: window screen
        #activeWindows   += [window]
        #inactiveWindows -= [window]
    }
    - deactivateWindow: window
    {
        self markScreenForReflowing: window screen
        #activeWindows   -= [window]
        #inactiveWindows += [window]
    }
    - removeWindow: window
    {
        self markScreenForReflowing: window screen
        #activeWindows   -= [window]
        #inactiveWindows -= [window]
    }

    - activateApplicationWithPID: pid
    {
        activated = #inactiveWindows select: `win| (win pid) == pid`
        activated each: { window |
            self markScreenForReflowing: window screen
            #inactiveWindows removeObject: window
            #activeWindows << window
        }
    }
    - deactivateApplicationWithPID: pid
    {
        deactivated = #activeWindows select: `win| (win pid) == pid`
        deactivated each: { window |
            self markScreenForReflowing: window screen
            #activeWindows removeObject: window
            #inactiveWindows << window
        }
    }
    - removeApplicationWithPID: pid
    {
        #activeWindows = #activeWindows select: `win| (win pid) != pid`
        #applications  = #applications  select: `app| (app pid) != pid`
    }

    - currentLayoutForScreen: screen `#layouts[#currLayouts[screen]]`
    - markScreenForReflowing: screen
    {
        `#screensThatNeedReflowing << screen` unless: (#screensThatNeedReflowing contains: screen)
    }
    - reflow
    {
        #screensThatNeedReflowing each: { screen |
            self currentLayoutForScreen:screen; reflow: self screen: screen
        }
        #screensThatNeedReflowing = []
    }

    - cycleLayouts `self cycleLayoutsForScreen: AccessibilityWindow frontMostWindow screen`
    - cycleLayoutsForScreen: screen
    {
        if ++#currLayouts[screen] >= #layouts count
            #currLayouts[screen] = 0
        self currentLayoutForScreen: screen; prepare: self
        self markScreenForReflowing: screen
    }

    - windowBefore: win `self currentLayoutForScreen: win screen; windowBefore: win inWm: self`
    - windowAfter:  win `self currentLayoutForScreen: win screen; windowAfter: win inWm: self`

    - selectPreviousWindow: window `self windowBefore: window; raise`
    - selectNextWindow: window     `self  windowAfter: window; raise`

    - swapWindow: a with: b
    {
        if a != b {
            idxA = #activeWindows indexOf: a
            idxB = #activeWindows indexOf: b
            #activeWindows[idxA], #activeWindows[idxB] = #activeWindows[idxB], #activeWindows[idxA]
            self markScreenForReflowing: a screen
            self markScreenForReflowing: b screen
        }
    }
    - swapWithPreviousWindow: window
    {
        self swapWindow: window with: (self windowBefore: window)
    }
    - swapWithNextWindow: window
    {
        self swapWindow: window with: (self windowAfter: window)
    }
    \ Swaps the window with it's closest counterpart on the other side
    - swapWithCounterpart: window
    {
        \ Get the existing reference managing the same physical window
        screen = window screen
        windows = self managedWindowsForScreen: screen
        idx = windows indexOf: window
        isOnLeft = idx < #windowsInMaster

        winCount = windows count
        if isOnLeft {
            otherIdx = #windowsInMaster + (winCount - #windowsInMaster) * (idx / #windowsInMaster)
            if (idx / #windowsInMaster) >= 0.5
                otherIdx = otherIdx ceil
        } else
            otherIdx = #windowsInMaster * ((idx - #windowsInMaster) / (winCount - #windowsInMaster))

        self swapWindow: window with: windows[otherIdx]
    }


    - focusOnScreen: screen
    {
        (self managedWindowsForScreen: screen) first raise
    }
    - moveWindow: window toScreen: destScreen
    {
        srcScreen = window screen
        if srcScreen == destScreen
            ^nil

        self markScreenForReflowing: srcScreen
        self markScreenForReflowing: destScreen

        #activeWindows removeObject: window
        #activeWindows insert: window at: 0

        screenFrame = destScreen flippedFrame
        windowsOnDestScreen = self managedWindowsForScreen: destScreen
        if windowsOnDestScreen count > 0 {
            currentlyFocused = windowsOnDestScreen[0]
            window setFrame: currentlyFocused frame
        } else
            window setFrame: screenFrame
    }

    - ratioForScreen: screen `#ratios[screen] || #defaultRatio`
    - setRatio: ratio forScreen: screen
    {
        #ratios[screen] = ratio
        self markScreenForReflowing: screen
    }
}
