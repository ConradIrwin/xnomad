import "Accessibility"
import "Layouts"

#NSNotificationCenter
{
    - observe: name with: lambda `self addObserverForName: name object: nil queue: nil usingBlock:lambda`
}

#WindowManager
{
    accessor: @applications             initialValue: []
    accessor: @activeWindows            initialValue: []
    accessor: @inactiveWindows          initialValue: []
    accessor: @windowsInMaster          initialValue: 1
    accessor: @screensThatNeedReflowing initialValue: []
    accessor: @defaultRatio             initialValue: 0.7
    accessor: @defaultMaxMasters        initialValue: 1

    - init
    {
        #currLayouts = {}
        #maxMasters  = {}
        #ratios      = {}
        NSScreen screens each: `screen| currLayouts[screen] = 0`

        #layouts = [TallLayout new, FullscreenLayout new]

        workspace = NSWorkspace sharedWorkspace
        workspace runningApplications each: { runningApp |
            unless runningApp bundleIdentifier hasPrefix: "com.apple.dashboard"
                self addApplicationWithPID: runningApp processIdentifier
        }
        \self currentLayout prepare: self

        center = workspace notificationCenter
        adder   = `n| ~self;    addApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        remover = `n| ~self; removeApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        activator   = `n| ~self;   activateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        deactivator = `n| ~self; deactivateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        center; observe: NSWorkspaceDidLaunchApplicationNotification    with: adder;
                observe: NSWorkspaceDidTerminateApplicationNotification with: remover;
                observe: NSWorkspaceDidUnhideApplicationNotification    with: activator;
                observe: NSWorkspaceDidHideApplicationNotification      with: deactivator
        ^self
    }

    - applicationWithPID: pid
    {
        ^#applications find: `app| (app pid) == pid`
    }
    - addApplicationWithPID: pid
    {
        if (self applicationWithPID: pid)
            ^nil
        app = AccessibilityElement withPID: pid
        unless app isKindOfClass: AccessibilityApplication
            ^nil
        #applications << app

        app[@AXWindows] each: { window |
            self addWindow: window active: (app[@AXHidden] == 0)
        }
        \ Watch for new window notifications
        app observe: @AXWindowCreated on: app with: { newWindow |
            ~self; addWindow: newWindow; reflow
        }
    }

    - addWindow: window `self addWindow: window active: yes`
    - addWindow: window active: isActive
    {
        unless window isKindOfClass: AccessibilityWindow
            ^nil

        self markScreenForReflowing: window screen
        unless window isResizable
            ^nil

        if isActive && window[@AXMinimized] != 1 {
            #activeWindows insert: window at: 0
        } else
            #inactiveWindows << window

        app = self applicationWithPID: window pid
        app observe: @AXUIElementDestroyed on: window with: { _ |
            ~self; removeWindow: window; reflow
        }
        app observe: @AXWindowMiniaturized on: window with: { _ |
            ~self; deactivateWindow: window; reflow
        }
        app observe: @AXWindowDeminiaturized on: window with: { _ |
            ~self; activateWindow: window; reflow
        }
        ^valid
    }

    - managedWindowsForScreen: screen
    {
        ^#activeWindows select: `w| (w level == 0) && (w screen == screen)`
    }
    - managedWindows `self managedWindowsForScreen: nil`

    - activateWindow: window
    {
        self markScreenForReflowing: window screen
        #activeWindows   += [window]
        #inactiveWindows -= [window]
    }
    - deactivateWindow: window
    {
        self markScreenForReflowing: window screen
        #activeWindows   -= [window]
        #inactiveWindows += [window]
    }
    - removeWindow: window
    {
        \ We need to get the original reference in order to access the cached screen
        window = #activeWindows find: `w| w == window`
        self markScreenForReflowing: window screen
        #activeWindows   -= [window]
        #inactiveWindows -= [window]
    }

    - activateApplicationWithPID: pid
    {
        activated = #inactiveWindows select: `win| (win pid) == pid`
        activated each: { window |
            self markScreenForReflowing: window screen
            #inactiveWindows removeObject: window
            #activeWindows << window
        }
    }
    - deactivateApplicationWithPID: pid
    {
        deactivated = #activeWindows select: `win| (win pid) == pid`
        deactivated each: { window |
            self markScreenForReflowing: window screen
            #activeWindows removeObject: window
            #inactiveWindows << window
        }
    }
    - removeApplicationWithPID: pid
    {
        windowsToRemove = #activeWindows select: `win| (win pid) == pid`
        windowsToRemove each: `w| self markScreenForReflowing: w screen`
        #activeWindows -= windowsToRemove
        #applications  = #applications  select: `app| (app pid) != pid`
    }

    - currentLayoutForScreen: screen `#layouts[#currLayouts[screen]]`
    - markScreenForReflowing: screen
    {
        `#screensThatNeedReflowing << screen` unless: (#screensThatNeedReflowing contains: screen)
    }
    - reflow
    {
        #screensThatNeedReflowing each: { screen |
            self currentLayoutForScreen:screen; reflow: self screen: screen
        }
        #screensThatNeedReflowing = []
    }

    - cycleLayouts `self cycleLayoutsForScreen: AccessibilityWindow frontMostWindow screen`
    - cycleLayoutsForScreen: screen
    {
        if ++#currLayouts[screen] >= #layouts count
            #currLayouts[screen] = 0
        self currentLayoutForScreen: screen; prepare: self
        self markScreenForReflowing: screen
    }

    - windowBefore: win `self currentLayoutForScreen: win screen; windowBefore: win inWm: self`
    - windowAfter:  win `self currentLayoutForScreen: win screen; windowAfter: win inWm: self`

    - selectPreviousWindow: window `self windowBefore: window; raise`
    - selectNextWindow: window     `self  windowAfter: window; raise`

    - swapWindow: a with: b
    {
        if a != b {
            idxA = #activeWindows indexOf: a
            idxB = #activeWindows indexOf: b
            #activeWindows[idxA], #activeWindows[idxB] = #activeWindows[idxB], #activeWindows[idxA]
            self markScreenForReflowing: a screen
            self markScreenForReflowing: b screen
        }
    }
    - swapWithPreviousWindow: window
    {
        self swapWindow: window with: (self windowBefore: window)
    }
    - swapWithNextWindow: window
    {
        self swapWindow: window with: (self windowAfter: window)
    }
    \ Swaps the window with it's closest counterpart on the other side
    - swapWithCounterpart: window
    {
        \ Get the existing reference managing the same physical window
        screen = window screen
        windows = self managedWindowsForScreen: screen
        idx = windows indexOf: window
        masterCount = self maxMastersOnScreen: screen
        isOnLeft = idx < masterCount

        winCount = windows count
        if isOnLeft {
            otherIdx = masterCount + (winCount - masterCount) * (idx / masterCount)
            if (idx / masterCount) >= 0.5
                otherIdx = otherIdx ceil
        } else
            otherIdx = masterCount * ((idx - masterCount) / (winCount - masterCount))

        self swapWindow: window with: windows[otherIdx]
    }


    - focusOnScreen: screen
    {
        (self managedWindowsForScreen: screen) first raise
    }
    - moveWindow: window toScreen: destScreen
    {
        srcScreen = window screen
        if srcScreen == destScreen
            ^nil

        self markScreenForReflowing: srcScreen
        self markScreenForReflowing: destScreen

        #activeWindows removeObject: window
        #activeWindows insert: window at: 0

        screenFrame = destScreen flippedFrame
        windowsOnDestScreen = self managedWindowsForScreen: destScreen
        if windowsOnDestScreen count > 0 {
            currentlyFocused = windowsOnDestScreen[0]
            window setFrame: currentlyFocused frame
        } else
            window setFrame: screenFrame
    }

    - ratioForScreen: screen `#ratios[screen] || #defaultRatio`
    - setRatio: ratio forScreen: screen
    {
        if (ratio > 0) && (ratio < 1) {
            #ratios[screen] = ratio
            self markScreenForReflowing: screen
        }
    }

    - maxMastersOnScreen: screen `#maxMasters[screen] || #defaultMaxMasters`
    - setMaxMasters: max onScreen: screen
    {
        if max > 0 {
            #maxMasters[screen] = max
            self markScreenForReflowing: screen
        }
    }
}
