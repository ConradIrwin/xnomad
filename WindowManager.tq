import "Accessibility"
import "Layouts"

#NSNotificationCenter
{
    - observe: name with: lambda `self addObserverForName: name object: nil queue: nil usingBlock:lambda`
}

#WindowManager
{
    accessor: @applications             initialValue: []
    accessor: @activeWindows            initialValue: []
    accessor: @inactiveWindows          initialValue: []
    accessor: @windowsInMaster          initialValue: 1
    accessor: @screensThatNeedReflowing initialValue: []
    accessor: @spacesThatNeedReflowing  initialValue: []
    accessor: @defaultRatio             initialValue: 0.7
    accessor: @defaultMaxMasters        initialValue: 1

    - init
    {
        #currLayouts = {}
        #maxMasters  = {}
        #ratios      = {}
        NSScreen screens each: `screen| #currLayouts[screen] = {}`

        #layouts = [TallLayout new, WideLayout new, FullscreenLayout new]

        workspace = NSWorkspace sharedWorkspace
        workspace runningApplications each: { runningApp |
            ^nil if runningApp bundleIdentifier hasPrefix: "com.apple.dashboard"
            self addApplicationWithPID: runningApp processIdentifier
        }

        center = workspace notificationCenter
        adder   = `n| ~self;    addApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        remover = `n| ~self; removeApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        activator   = `n| ~self;   activateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        deactivator = `n| ~self; deactivateApplicationWithPID: (n#userInfo[@NSWorkspaceApplicationKey] processIdentifier); reflow`
        center; observe: NSWorkspaceDidLaunchApplicationNotification    with: adder;
                observe: NSWorkspaceDidTerminateApplicationNotification with: remover;
                observe: NSWorkspaceDidUnhideApplicationNotification    with: activator;
                observe: NSWorkspaceDidHideApplicationNotification      with: deactivator
        ^self
    }

    - currentSpaceId `CGSCopySpaces(_CGSDefaultConnection(), KCGSSpaceCurrent)[0]`
    - currentSpace
    {
        spaces = CGSCopySpaces(_CGSDefaultConnection(), KCGSSpaceAll)
        idx    = spaces indexOfObject: self currentSpaceId
        ^spaces count - idx
    }
    - switchToSpace: idx
    {
        spaces = CGSCopySpaces(_CGSDefaultConnection(), KCGSSpaceAll)
        ^nil if spaces count <= idx
        currentSpace = CGSCopySpaces(_CGSDefaultConnection(), KCGSSpaceCurrent)[0]
        destSpace    = spaces[spaces count - idx - 1]
        if currentSpace ~= destSpace {
            CGSHideSpaces(_CGSDefaultConnection(), [currentSpace])
            CGSShowSpaces(_CGSDefaultConnection(), [destSpace])
            CGSManagedDisplaySetCurrentSpace(_CGSDefaultConnection(), KCGSPackagesMainDisplayIdentifier, destSpace)
            self markSpaceForReflowing: destSpace
            self markAllScreensForReflowing
            (self managedWindowsForScreen: NSScreen mainScreen spaces: [destSpace]) first raise
        }
    }
    \ This doesn't work yet, not sure if my function prototype is wrong, or if you need elevated permissions to move windows around
    - moveWindow: window toSpace: destSpaceIdx
    {
        conn   = _CGSDefaultConnection()
        spaces = CGSCopySpaces(conn, KCGSSpaceAll)
        srcSpace  = window spaceId
        destSpace = spaces[destSpaceIdx]

        ^nil if srcSpace == destSpace
        CGSRemoveWindowsFromSpaces(conn, [window _cgWindow], [srcSpace])
        CGSAddWindowsToSpaces(conn, [window _cgWindow], [destSpace])
    }

    - applicationWithPID: pid
    {
        ^#applications find: `app| (app pid) == pid`
    }
    - addApplicationWithPID: pid
    {
        ^nil if self applicationWithPID: pid
        app = AccessibilityElement withPID: pid
        ^nil unless app isKindOfClass: AccessibilityApplication
        #applications push: app

        app[@AXWindows] each: { window |
            self addWindow: window active: (app[@AXHidden] == 0)
        }
        \ Watch for new window notifications
        app observe: @AXWindowCreated on: app with: { newWindow |
            ~self; addWindow: newWindow; reflow
        }
    }

    - addWindow: window `self addWindow: window active: yes`
    - addWindow: window active: isActive
    {
        ^nil unless window isKindOfClass: AccessibilityWindow

        self markScreenForReflowing: window screen
        self markSpacesForReflowing: window spaceIds
        ^nil unless window isResizable

        if isActive && window[@AXMinimized] ~= 1 {
            #activeWindows insert: window at: 0
        } else
            #inactiveWindows push: window

        app = self applicationWithPID: window pid
        app observe: @AXUIElementDestroyed on: window with: { w |
            ~self; removeWindow: window; reflow
        }
        app observe: @AXWindowMiniaturized on: window with: { w |
            ~self; deactivateWindow: window; reflow
        }
        app observe: @AXWindowDeminiaturized on: window with: { w |
            ~self; activateWindow: window; reflow
        }
        ^valid
    }

    - managedWindowsForScreen: screen spaces: spaceIds
    {
        ^#activeWindows select: { window |
            ^no unless (window level == 0) && (window screen == screen)
            windowSpaces = window spaceIds
            spaceIds each: { id |
                ^^yes if windowSpaces containsObject: id
            }
            ^no
        }
    }

    - activateWindow: window
    {
        self markScreenForReflowing: window screen
        self markSpacesForReflowing: window spaceIds
        #activeWindows   += [window]
        #inactiveWindows -= [window]
    }
    - deactivateWindow: window
    {
        self markScreenForReflowing: window screen
        self markSpacesForReflowing: window spaceIds
        #activeWindows   -= [window]
        #inactiveWindows += [window]
    }
    - removeWindow: window
    {
        \ We need to get the original reference in order to access the cached screen
        window = #activeWindows find: `w| w == window`
        self markScreenForReflowing: window screen
        self markSpacesForReflowing: window spaceIds
        #activeWindows   -= [window]
        #inactiveWindows -= [window]
    }

    - activateApplicationWithPID: pid
    {
        activated = #inactiveWindows select: `win| (win pid) == pid`
        activated each: { window |
            self markScreenForReflowing: window screen
            self markSpacesForReflowing: window spaceIds
            #inactiveWindows removeObject: window
            #activeWindows push: window
        }
    }
    - deactivateApplicationWithPID: pid
    {
        deactivated = #activeWindows select: `win| (win pid) == pid`
        deactivated each: { window |
            self markScreenForReflowing: window screen
            self markSpacesForReflowing: window spaceIds
            #activeWindows removeObject: window
            #inactiveWindows push: window
        }
    }
    - removeApplicationWithPID: pid
    {
        windowsToRemove = #activeWindows select: `win| (win pid) == pid`
        windowsToRemove each: { window |
            self markScreenForReflowing: window screen
            self markSpacesForReflowing: window spaceIds
        }
        #activeWindows -= windowsToRemove
        #applications  = #applications  select: `app| (app pid) ~= pid`
    }

    - markAllScreensForReflowing `NSScreen screens each: { s | self markScreenForReflowing: s }`
    - markScreenForReflowing: screen
    {
        #screensThatNeedReflowing push: screen unless #screensThatNeedReflowing contains: screen
    }
    - markSpaceForReflowing: spaceId
    {
        #spacesThatNeedReflowing push: spaceId unless #spacesThatNeedReflowing contains: spaceId
    }
    - markSpacesForReflowing: spaceIds
    {
        spaceIds each: `spaceId| self markSpaceForReflowing: spaceId `
    }
    - reflow
    {
        currSpace = self currentSpaceId
        ^nil unless #spacesThatNeedReflowing containsObject: currSpace
        #screensThatNeedReflowing each: { screen |
            self currentLayoutForScreen:screen space:currSpace; reflow: self screen:screen spaces:[currSpace]
        }
        #screensThatNeedReflowing = []
        #spacesThatNeedReflowing -= [currSpace]
        ^nil
    }

    - cycleLayouts `self cycleLayoutsForScreen: AccessibilityWindow frontMostWindow screen space: self currentSpaceId`
    - cycleLayoutsForScreen: screen space: spaceId
    {
        layoutsForScreen = #currLayouts[screen]
        layoutsForScreen[spaceId] ||= 0
        layoutsForScreen[spaceId] = 0 if ++layoutsForScreen[spaceId] >= #layouts count
        self currentLayoutForScreen:screen space:spaceId; prepare:self
        self markScreenForReflowing:screen
        self markSpaceForReflowing:spaceId
    }
    - currentLayoutForScreen: screen space: spaceId
    {
        layoutsForScreen = #currLayouts[screen]
        layoutsForScreen[spaceId] ||= 0
        ^#layouts[layoutsForScreen[spaceId]]
    }

    - windowBefore:   win `self currentLayoutForScreen: win screen space:self currentSpaceId;  windowBefore: win inWm: self`
    - windowAfter:    win `self currentLayoutForScreen: win screen space:self currentSpaceId;   windowAfter: win inWm: self`
    - focusOnWindow:  win `self currentLayoutForScreen: win screen space:self currentSpaceId; focusOnWindow: win inWm: self`

    - selectPreviousWindow: window `self focusOnWindow: (self windowBefore: window)`
    - selectNextWindow: window     `self focusOnWindow: (self windowAfter: window)`

    - swapWindow: a with: b
    {
        if a ~= b {
            idxA = #activeWindows indexOf: a
            idxB = #activeWindows indexOf: b
            #activeWindows[idxA], #activeWindows[idxB] = #activeWindows[idxB], #activeWindows[idxA]
            self markScreenForReflowing: a screen
            self markSpacesForReflowing: a spaceIds
            self markScreenForReflowing: b screen
            self markSpacesForReflowing: b spaceIds
        }
    }
    - swapWithPreviousWindow: window
    {
        self swapWindow: window with: (self windowBefore: window)
    }
    - swapWithNextWindow: window
    {
        self swapWindow: window with: (self windowAfter: window)
    }
    \ Swaps the window with it's closest counterpart on the other side
    - swapWithCounterpart: window
    {
        \ Get the existing reference managing the same physical window
        screen = window screen
        windows = self managedWindowsForScreen: screen spaces: window spaceIds
        idx = windows indexOf: window
        masterCount = self maxMastersOnScreen: screen
        isOnLeft = idx < masterCount

        winCount = windows count
        if isOnLeft {
            otherIdx = masterCount + (winCount - masterCount) * (idx / masterCount)
            otherIdx = otherIdx ceil if (idx / masterCount) >= 0.5
        } else
            otherIdx = masterCount * ((idx - masterCount) / (winCount - masterCount))

        self swapWindow: window with: windows[otherIdx]
    }


    - focusOnScreen: screen
    {
        (self managedWindowsForScreen: screen spaces: [self currentSpaceId]) first raise
    }
    - moveWindow: window toScreen: destScreen
    {
        srcScreen = window screen
        ^nil if srcScreen == destScreen

        self markScreenForReflowing: srcScreen
        self markScreenForReflowing: destScreen

        #activeWindows removeObject: window
        #activeWindows insert: window at: 0

        screenFrame = destScreen flippedFrame
        windowsOnDestScreen = self managedWindowsForScreen: destScreen spaces: [self currentSpaceId]
        if windowsOnDestScreen count > 0 {
            currentlyFocused = windowsOnDestScreen[0]
            window setFrame: currentlyFocused frame
        } else
            window setFrame: screenFrame
    }

    - ratioForScreen: screen `#ratios[screen] || #defaultRatio`
    - setRatio: ratio forScreen: screen
    {
        if (ratio > 0) && (ratio < 1) {
            #ratios[screen] = ratio
            self markScreenForReflowing: screen
            self markSpaceForReflowing: self currentSpaceId
        }
    }

    - maxMastersOnScreen: screen `#maxMasters[screen] || #defaultMaxMasters`
    - setMaxMasters: max onScreen: screen
    {
        if max > 0 {
            #maxMasters[screen] = max
            self markScreenForReflowing: screen
            self markSpaceForReflowing: self currentSpaceId
        }
    }
}
